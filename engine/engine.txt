package engine

import("fmt"
	. "gfx"
	"time"
	"math"
)

	// Global Variables
var SX,SY uint16
var CanvasWidth,CanvasHeight float64 = 2,2
var MainCamera [4][4]float64 = [4][4]float64{
		[4]float64{1	,0	,0	,0},
		[4]float64{0	,1	,0	,0},
		[4]float64{0	,0	,1	,0},
		[4]float64{0	,0	,0	,1}}
// Options
var DoDebugging bool = false
// Internal loops
var QuitGame,QuitKeyboardInput,QuitMouseInput,QuitProgram bool
// Program entry point
func main(){
	for !QuitProgram{
		states[ProgramState]()
	}
	FensterAus()
	fmt.Println("about to shutdown...")
	fmt.Scanln()
}

// Program States
var ProgramState int = 0
type State func()
var states []State = []State{MainMenu,GameLoop,SettingsMenu}

func GameLoop(){
	QuitGame = false
	
	// Scene setup
	InstantiateEntity(Entity{0,IdentityMatrix(),Vec3f{0,1,0},[]Tri3f{Tri3f{Vec3f{10,0,10}, Vec3f{10,0,-10},Vec3f{-10,0,10}},Tri3f{Vec3f{-10,0,10}, Vec3f{10,0,-10},Vec3f{-10,0,-10}}}})
	//entityList[0].transform = Translate(entityList[0].transform, Vec3f{0,0,20})
	
	// Clock zero
	t0 := time.Now()
	t0=t0
	t1 := time.Now()
	// Seconds elapsed since last frame
	deltaTime := float64(0)
	
	go KeyboardInput()
	go MouseInput()
	
	//Camera Rotation values
	MausLock()
	
	// Game loop
	for !QuitGame{
		// Calculate deltaTime
		deltaTime = float64(time.Now().Sub(t1).Nanoseconds())/10000000
		if DoDebugging {fmt.Println("fps :",1/deltaTime)}
		t1 = time.Now()
		
		// Move Player
		if DoDebugging {fmt.Println(MousePos)}
		playerInput := Vec3f{GetAxis(Left,Right),GetAxis(Shift,Space),GetAxis(Down,Up)}
		MainCamera = Rotate(MainCamera, Vec3f{CamRot.y/100,CamRot.x/100,0})
		MainCamera = Translate(MainCamera, Times(playerInput,ValVec(1 * deltaTime)))
		entityList[0].transform = SetPosition(entityList[0].transform, Vec3f{0,math.Sin(time.Now().Sub(t0).Seconds()) * 5 - 10,10})
		
		// Draw
		UpdateAus()
		
		Stiftfarbe(0,0,0)
		Cls()
		
		for i:=0;i<len(entityList);i++{
			// Draw Mesh
			Stiftfarbe(VecToColor(entityList[i].color))
			for k:=0;k<len(entityList[i].mesh);k++{
				// Local to world
				tri := Tri3fTransform(entityList[i].mesh[k], entityList[i].transform)
				// World to Camera
				tri = Tri3fTransform(tri, Inverse(MainCamera))
				// Camera to canvas
				tri = Tri3f{CameraToCanvas(tri.a),CameraToCanvas(tri.b),CameraToCanvas(tri.c)}
				if CullCamera(tri.a) && CullCamera(tri.b) && CullCamera(tri.c){ continue}
				// Canvas to NDC
				tri2 := Tri2f{CanvasToNdc(tri.a),CanvasToNdc(tri.b),CanvasToNdc(tri.c)}
				// NDC to Raster
				triRaster := Tri2ui{NdcToRaster(tri2.a),NdcToRaster(tri2.b),NdcToRaster(tri2.c)}
				// Convert to uint16
				DrawTriangle(triRaster)
			}
		}
		// Draw aim pointer
		Stiftfarbe(255,255,255)
		Vollkreis(SX/2,SY/2,3)
		
		UpdateAn()
	}
	
	MausUnlock()
}

func MainMenu(){
	ResizeWindow(800,800)
	
	selected := 0
	
	for {
		UpdateAus()
		
		Stiftfarbe(255,255,0)
		Cls()
		
		if selected == 0{
			Stiftfarbe(255,0,0)
		} else {
			Stiftfarbe(0,0,0)
		}
		SetzeFont("Minecraft.ttf", 30)
		SchreibeFont(SX/2-30,SY/2-100,"Play")
		
		if selected == 1{
			Stiftfarbe(255,0,0)
		} else {
			Stiftfarbe(0,0,0)
		}
		SetzeFont("Minecraft.ttf", 30)
		SchreibeFont(SX/2-56,SY/2-60,"Settings")
		
		UpdateAn()
		
		a,b,_ := TastaturLesen1()
		if DoDebugging {fmt.Println(a, selected)}
		if b==1{
			if a == 27{
				QuitProgram = true
				return
			}
			if a == 13{
				if selected == 0{
					ProgramState = 1
					return
				}
				if selected == 1{
					ProgramState = 2
					return
				}
			}
			if a == 273{selected-- }
			if a == 274{selected = (selected + 1)%2}
			if selected < 0{selected = 1}
		}
	}
}

func SettingsMenu(){
	ResizeWindow(800,800)
	
	for {
		UpdateAus()
		
		Stiftfarbe(255,255,0)
		Cls()
		
		Stiftfarbe(255,0,0)
		
		SetzeFont("Minecraft.ttf", 30)
		SchreibeFont(SX/2-30,SY/2-100,"Settings")
		
		UpdateAn()
		
		a,b,_ := TastaturLesen1()
		if DoDebugging{fmt.Println(a)}
		if b==1{
			if a == 27{
				QuitProgram = true
				return
			}
			if a == 13{
				ProgramState = 0
				return
			}
		}
	}
}

// Global Functions

func ResizeWindow(sizeX,sizeY uint16){
	// Clamp Size
	if sizeX > 1920{sizeX = 1920}
	if sizeY > 1200{sizeY = 1200}
	// Don't Resize if size is same as before
	if SX == sizeX || SY == sizeY{return}
	// Resize window to new size
	FensterAus()
	SX,SY = sizeX,sizeY
	Fenster(sizeX,sizeY)
}

	// Classes

// Input Class
var CamRot Vec2f
var MousePos Vec2ui = Vec2ui{400,400}// Mouse cursor position
var Shift,Space,Up,Down,Right,Left bool // Keyboard state inputs
func MouseInput(){
	QuitMouseInput = false
	MauspufferAn()
	for !QuitMouseInput {
		// Get Mouse Input from the buffer
		,,x,y := MauspufferLesen1()
		// Process it
		MousePos = Vec2ui{x,y}
		CamRot = Vec2f{CamRot.x + float64(x) - float64(SX/2),CamRot.y + float64(y) - float64(SY/2)}
	}
	MauspufferAus()
}

func KeyboardInput(){
	QuitKeyboardInput = false
	TastaturpufferAn()
	for !QuitKeyboardInput {
		// Get Keyboard Input from the buffer
		a,b,c := TastaturpufferLesen1()
		// Process it
		ProcessKeyboardInput(a,b,c)
	}
	TastaturpufferAus()
}

func ProcessKeyboardInput(a uint16, b uint8, c uint16){
	// Turn press input into a bool
		press := true
		if b == 0 {press = false}
		
		// Switch appropriate bool on/off
		switch a {
			case 27: // esc
				QuitMouseInput = true
				QuitKeyboardInput = true
				QuitProgram = true
				QuitGame = true
				break;
			case 32: // space
				Space = press
				break;
			case 304: // space
				Shift = press
				break;
			case 273: // Up key
				Up = press
				break;
			case 274: // Down key
				Down = press
				break;
			case 275: // Right key
				Right = press
				break;
			case 276: // Left key
				Left = press
				break;
			}
}

func GetAxis(neg,pos bool)float64{
	ax := float64(0)
	if neg {ax--}
	if pos {ax++}
	return ax
}

// Entity Class

var entityList []Entity // List of all existing entities

type Entity struct{
	index int // Index in the entity list
	transform [4][4]float64
	color Vec3f // Color of this entity
	mesh []Tri3f // Triangles of this entity
}

func DestroyEntity(i int){
	entityList[i] = entityList[len(entityList)-1]
	entityList = entityList[:len(entityList)-1]
	for i = i; i < len(entityList); i++{
		entityList[i].index = i;
	}
}

func InstantiateEntity(e Entity){
	e.index = len(entityList)
	entityList = append(entityList,e)
}

// Triangle 2D float64

type Tri2f struct{
	a,b,c Vec2f
}

// Triangle 2D uint16

type Tri2ui struct{
	a,b,c Vec2ui
}

// Triangle 3D float64

type Tri3f struct{
	a,b,c Vec3f
}

func Tri3fTransform(t Tri3f, mat [4][4]float64) Tri3f {
	t.a = MultPointMatrix(t.a, mat)
	t.b = MultPointMatrix(t.b, mat)
	t.c = MultPointMatrix(t.c, mat)
	return t
}

// Vector 3D float64

type Vec3f struct{
	x,y,z float64
}

func ValVec(n float64)Vec3f{
	return Vec3f{n,n,n}
}

func Plus(a,b Vec3f)Vec3f{
	return Vec3f{a.x+b.x,a.y+b.y,a.z+b.z}
}

func Minus(a,b Vec3f)Vec3f{
	return Vec3f{a.x-b.x,a.y-b.y,a.z-b.z}
}

func Times(a,b Vec3f)Vec3f{
	return Vec3f{a.x*b.x,a.y*b.y,a.z*b.z}
}

func Div(a,b Vec3f)Vec3f{
	return Vec3f{a.x/b.x,a.y/b.y,a.z/b.z}
}

func Len(vec Vec3f) float64{
	return math.Sqrt(vec.x*vec.x+vec.y*vec.y+vec.z*vec.z)
}

func Dist(vec1, vec2 Vec3f) (dist float64){
	return Len(Minus(vec1,vec2))
}

func Normalize(vec Vec3f)(q Vec3f){
	return Div(vec,ValVec(Len(vec)))
}

func Abs(vec Vec3f) Vec3f{
	return Vec3f{MathAbs(vec.x),MathAbs(vec.y),MathAbs(vec.z)}
}

func Max(vec1, vec2 Vec3f) Vec3f{
	return Vec3f{math.Max(vec1.x,vec2.x),math.Max(vec1.y,vec2.y),math.Max(vec1.z,vec2.z)}
}

func Min(vec1, vec2 Vec3f) Vec3f{
	return Vec3f{math.Min(vec1.x,vec2.x),math.Min(vec1.y,vec2.y),math.Min(vec1.z,vec2.z)}
}

func Dot(vec1, vec2 Vec3f) (dist float64){
	return vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z
}

func Cross(vec1, vec2 Vec3f) Vec3f{
	return Vec3f{vec1.y*vec2.z-vec1.z*vec2.y,
		vec1.z*vec2.x-vec1.x*vec2.z,
		vec1.x*vec2.y-vec1.y*vec2.x}
}

func ProjectOnVector(point, normal Vec3f) Vec3f{
    return Times(ValVec(Dot(point, normal)), normal)
}

func ProjectOnPlane(point, normal Vec3f) Vec3f{
	return Minus(point, Times(ValVec(Dot(normal, point)), normal))
}

func Clamp(vec Vec3f, min, max float64) Vec3f{
	return Vec3f{MathClamp(vec.x,min,max),MathClamp(vec.y,min,max),MathClamp(vec.z,min,max)}
}

func VecToColor(vec Vec3f) (r,g,b uint8){
	vec = Times(vec,ValVec(255))
	return uint8(vec.x),uint8(vec.y),uint8(vec.z)
}

// Vector 2D float64

type Vec2f struct{
	x,y float64
}

// Vector 2D uint16

type Vec2ui struct{
	x,y uint16
}

func CullCamera(camera Vec3f) bool{
	if camera.z < 0{return false}
		return true
}

func CameraToCanvas(world Vec3f)(canvas Vec3f){
	canvas = Vec3f{world.x/world.z,world.y/world.z,-world.z}
	return canvas
}

func CanvasToNdc(canvas Vec3f)(ndc Vec2f){
	ndc = Vec2f{(canvas.x + CanvasWidth / 2) / CanvasWidth,(canvas.y + CanvasHeight / 2) / CanvasHeight}
	return ndc
}

func NdcToRaster(ndc Vec2f)(raster Vec2ui){
	raster = Vec2ui{uint16(ndc.x * float64(SX)), uint16((1-ndc.y) * float64(SY))}
	return raster
}

func DrawTriangle(tRaster Tri2ui){
	Volldreieck(tRaster.a.x,tRaster.a.y,tRaster.b.x,tRaster.b.y,tRaster.c.x,tRaster.c.y)
}

// Matrix 4x4 float64

func IdentityMatrix() [4][4]float64{
	return [4][4]float64{
		[4]float64{1	,0	,0	,0},
		[4]float64{0	,1	,0	,0},
		[4]float64{0	,0	,1	,0},
		[4]float64{0	,0	,0	,1}}
}

func Translate(mat [4][4]float64, vec Vec3f)[4][4]float64{
	if vec.x != 0{mat[3][0] += vec.x}
	if vec.y != 0{mat[3][1] += vec.y}
	if vec.z != 0{mat[3][2] += vec.z}
	return mat
}

func SetPosition(mat [4][4]float64, vec Vec3f)[4][4]float64{
	mat[3][0] = vec.x
	mat[3][1] = vec.y
	mat[3][2] = vec.z
	return mat
}

func Rotate(mat [4][4]float64, vec Vec3f)[4][4]float64{
	if vec.x != 0{
		mat[1][1] = math.Cos(vec.x)
		mat[2][1] = -math.Sin(vec.x)
		mat[1][1] = math.Cos(vec.x)
		mat[2][2] = math.Sin(vec.x)
	}
	if vec.y != 0{
		mat[0][0] = math.Cos(vec.y)
		mat[2][0] = math.Sin(vec.y)
		mat[0][2] = -math.Sin(vec.y)
		mat[2][2] = math.Cos(vec.y)
	}
	if vec.z != 0{
		mat[0][0] = math.Cos(vec.z)
		mat[1][0] = -math.Sin(vec.z)
		mat[0][1] = math.Sin(vec.z)
		mat[1][1] = math.Cos(vec.z)
	}
	return mat
}

func SetRotation(mat [4][4]float64, vec Vec3f)[4][4]float64{
	if vec.x != 0{
		mat[1][1] = math.Cos(vec.x)
		mat[2][1] = -math.Sin(vec.x)
		mat[1][1] = math.Cos(vec.x)
		mat[2][2] = math.Sin(vec.x)
	}
	if vec.y != 0{
		mat[0][0] = math.Cos(vec.y)
		mat[2][0] = math.Sin(vec.y)
		mat[0][2] = -math.Sin(vec.y)
		mat[2][2] = math.Cos(vec.y)
	}
	if vec.z != 0{
		mat[0][0] = math.Cos(vec.z)
		mat[1][0] = -math.Sin(vec.z)
		mat[0][1] = math.Sin(vec.z)
		mat[1][1] = math.Cos(vec.z)
	}
	return mat
}

func Inverse(mat [4][4]float64)[4][4]float64{
	if Determinant(mat) == 0{return mat}
	
	mat1 := IdentityMatrix()	
	
	for i := 0; i < 4; i++ {
		pivot := mat[i][i]
		
		if pivot != 1 && pivot != 0 {
			for t := i; t < 4; t++ {
				mat[i][t] = mat[i][t]/pivot
				mat1[i][t] = mat1[i][t]/pivot
			}
		}
	
		//Update to the new pivot which must be 1.0
		pivot = mat[i][i]
	
		for j := 0; j < 4; j++{
			if j==i {
				continue
			} else {
				l := mat[j][i]/pivot;
				for m := 0; m < 4; m++ {
					mat[j][m] = mat[j][m] - l * mat[i][m];
					mat1[j][m] = mat1[j][m] - (l * mat1[i][m])
				}
			}
		}
	}
	return mat1
}

func Determinant(mat [4][4]float64)float64{
	return mat[0][0]*mat[1][1]*mat[2][2]*mat[3][3] + mat[1][0]*mat[2][1]*mat[3][2]*mat[0][3] + 
	mat[2][0]*mat[3][1]*mat[0][2]*mat[1][3] + mat[3][0]*mat[0][1]*mat[1][2]*mat[2][3] -
	mat[3][0]*mat[2][1]*mat[1][2]*mat[0][3] - mat[2][0]*mat[1][1]*mat[0][2]*mat[3][3] -
	mat[1][0]*mat[0][1]*mat[3][2]*mat[2][3] - mat[0][0]*mat[3][1]*mat[2][2]*mat[1][3]
}

func MultPointMatrix(p Vec3f, mat [4][4]float64)(p1 Vec3f){
	p1.x = p.x * mat[0][0] + p.y * mat[1][0] + p.z * mat[2][0] + mat[3][0]
	p1.y = p.x * mat[0][1] + p.y * mat[1][1] + p.z * mat[2][1] + mat[3][1]
	p1.z = p.x * mat[0][2] + p.y * mat[1][2] + p.z * mat[2][2] + mat[3][2]
	w   := p.x * mat[0][3] + p.y * mat[1][3] + p.z * mat[2][3] + mat[3][3]
	if w != 1 && w != 0 {
		p.x,p.y,p.z = p.x/w,p.y/w,p.z/w
	}
	return
}

// Math supplement functions

func MathAbs(n float64) float64{
	if n<0{return -n}
	return n
}

func DegToRad(deg float64) float64{
	return deg*0.01745
}

func MathClamp(n,min,max float64)float64{
	return math.Max(math.Min(n,max),min)
}